package util

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/binary"
	"fmt"
	"hash"
	"io"
	"math/big"
	"os"
	"strings"

	"encoding/json"

	"github.com/ok-chain/okchain/common"
	"github.com/ok-chain/okchain/core/types"
	logging "github.com/ok-chain/okchain/log"
	"golang.org/x/crypto/sha3"
)

type alg struct {
	hashFun func([]byte) string
}

type algFactory func() hash.Hash

const defaultAlg = "sha3"

var logger = logging.MustGetLogger("debug")

var availableIDgenAlgs = map[string]alg{
	defaultAlg: {GenerateIDfromTxSHAHash},
}

var availableHashAlgs = map[string]algFactory{
	defaultAlg: sha3.New256,
	"sha256":   sha256.New,
}

func OkChainPanic(format string, args ...interface{}) {
	logger.Errorf("--------------------------------------------------------")
	logger.Errorf(format, args...)
	logger.Errorf("--------------------------------------------------------")
	panic("")
}

func DefaultCryptoHash() hash.Hash {
	return availableHashAlgs[defaultAlg]()
}

func Hash(data interface{}) common.Hash {
	return types.RlpHash(data)
}

func CryptoHashByAlg(alg string) hash.Hash {
	if alg == "" {
		return DefaultCryptoHash()
	}
	factory, ok := availableHashAlgs[alg]
	if ok {
		return factory()
	} else {
		return nil
	}
}

// ComputeCryptoHash should be used in openchain code so that we can change the actual algo used for crypto-hash at one place
func ComputeCryptoHash(data []byte) (hash []byte) {
	hash = make([]byte, 64)
	sha3.ShakeSum256(hash, data)
	return
}

// GenerateBytesUUID returns a UUID based on RFC 4122 returning the generated bytes
func GenerateBytesUUID() []byte {
	uuid := make([]byte, 16)
	_, err := io.ReadFull(rand.Reader, uuid)
	if err != nil {
		panic(fmt.Sprintf("Error generating UUID: %s", err))
	}

	// variant bits; see section 4.1.1
	uuid[8] = uuid[8]&^0xc0 | 0x80

	// version 4 (pseudo-random); see section 4.1.3
	uuid[6] = uuid[6]&^0xf0 | 0x40

	return uuid
}

// GenerateIntUUID returns a UUID based on RFC 4122 returning a big.Int
func GenerateIntUUID() *big.Int {
	uuid := GenerateBytesUUID()
	z := big.NewInt(0)
	return z.SetBytes(uuid)
}

// GenerateUUID returns a UUID based on RFC 4122
func GenerateUUID() string {
	uuid := GenerateBytesUUID()
	return idBytesToStr(uuid)
}

//GenerateHashFromSignature returns a hash of the combined parameters
func GenerateHashFromSignature(path string, args []byte) []byte {
	return ComputeCryptoHash(args)
}

// Deprecated: GenerateIDfromTxSHAHash generates SHA256 hash using Tx payload
func GenerateIDfromTxSHAHash(payload []byte) string {
	return fmt.Sprintf("%x", sha256.Sum256(payload))
}

// GenerateIDfromTxSHAHash generates SHA256 hash using Tx payload
func GenerateIDfromDigest(d []byte) string {
	if len(d) > 32 {
		return fmt.Sprintf("%x", d[:32])
	} else {
		return fmt.Sprintf("%x", d)
	}
}

// GenerateIDWithAlg generates an ID using a custom algorithm
func GenerateIDWithAlg(customIDgenAlg string, payload []byte) (string, error) {
	if customIDgenAlg == "" {
		customIDgenAlg = defaultAlg
	}
	var alg = availableIDgenAlgs[customIDgenAlg]
	if alg.hashFun != nil {
		return alg.hashFun(payload), nil
	}
	return "", fmt.Errorf("Wrong ID generation algorithm was given: %s", customIDgenAlg)
}

func idBytesToStr(id []byte) string {
	return fmt.Sprintf("%x-%x-%x-%x-%x", id[0:4], id[4:6], id[6:8], id[8:10], id[10:])
}

// FindMissingElements identifies the elements of the first slice that are not present in the second
// The second slice is expected to be a subset of the first slice
func FindMissingElements(all []string, some []string) (delta []string) {
all:
	for _, v1 := range all {
		for _, v2 := range some {
			if strings.Compare(v1, v2) == 0 {
				continue all
			}
		}
		delta = append(delta, v1)
	}
	return
}

func ToChaincodeArgs(args ...string) [][]byte {
	bargs := make([][]byte, len(args))
	for i, arg := range args {
		bargs[i] = []byte(arg)
	}
	return bargs
}

func ArrayToChaincodeArgs(args []string) [][]byte {
	bargs := make([][]byte, len(args))
	for i, arg := range args {
		bargs[i] = []byte(arg)
	}
	return bargs
}

func MkdirIfNotExist(targetDir string) bool {
	missing, err := dirMissingOrEmpty(targetDir)
	if err != nil {
		panic(fmt.Sprintf("Error while trying to open DB: %s", err))
	}

	if missing {
		err = os.MkdirAll(targetDir, 0755)
		if err != nil {
			panic(fmt.Sprintf("Error making directory path [%s]: %s", targetDir, err))
		}
	}
	return missing
}

func dirMissingOrEmpty(path string) (bool, error) {
	dirExists, err := dirExists(path)
	if err != nil {
		return false, err
	}
	if !dirExists {
		return true, nil
	}

	dirEmpty, err := dirEmpty(path)
	if err != nil {
		return false, err
	}
	if dirEmpty {
		return true, nil
	}
	return false, nil
}

func dirExists(path string) (bool, error) {
	_, err := os.Stat(path)
	if err == nil {
		return true, nil
	}
	if os.IsNotExist(err) {
		return false, nil
	}
	return false, err
}

func dirEmpty(path string) (bool, error) {
	f, err := os.Open(path)
	if err != nil {
		return false, err
	}
	defer f.Close()

	_, err = f.Readdir(1)
	if err == io.EOF {
		return true, nil
	}
	return false, err
}

func EncodeUint64(number uint64) []byte {
	bytes := make([]byte, 8)
	binary.BigEndian.PutUint64(bytes, number)
	return bytes
}

func DecodeToUint64(bytes []byte) uint64 {
	return binary.BigEndian.Uint64(bytes)
}

func EncodeStatehash(statehash []byte) string {
	return fmt.Sprintf("%x", statehash)
}

func JsonFormat(v interface{}) string {
	b, err := json.MarshalIndent(v, "", "  ")
	if err == nil {
		return string(b)
	}
	return ""
}
